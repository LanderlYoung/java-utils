package com.young.util.jni.generator;

import com.young.util.jni.JNIHelper;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.Diagnostic;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.List;

/**
 * Author: taylorcyang
 * Date:   2014-12-17
 * Time:   16:03
 * Life with passion. Code with creativity!
 */
public class CppCodeGenerator implements Runnable {
    private final Environment mEnv;
    private final Element mClazz;
    private List<Element> mMethods;
    private String mClassName;
    private String mJNIClassName;
    private String mFullClassName;
    private String mHeaderName;
    private String mSourceName;
    private int mTargetArch;


    //DONE JNIHelper.toJNIType throwable
    //DONE Use NativeClass to mark generate, NativeMethod to add implements
    //DELETE different constant value for different arch
    //TODO file output

    public CppCodeGenerator(Environment env,
                            TypeElement clazz) {
        mEnv = env;
        mClazz = clazz;
        mMethods = new LinkedList<Element>();
    }

    @Override
    public void run() {
        doGenerate();
    }

    public void doGenerate() {
        init();
        if (!mMethods.isEmpty()) {
            genHeader();
            genSource();
        }
    }

    private void init() {
        assert mClazz.getKind().equals(ElementKind.METHOD);
        Element pkg = mClazz.getEnclosingElement();
        String pkgName = pkg != null ? pkg.getSimpleName().toString() : "";
        String className = mClazz.getSimpleName().toString();
        if (pkgName.equals("")) {
            mClassName = className;
        } else {
            mClassName = pkgName + '.' + className;
        }
        mJNIClassName = JNIHelper.toJNIClassName(mClassName);
        mHeaderName = "_" + mJNIClassName + ".h";
        mSourceName = "_" + mJNIClassName + ".cpp";
        mFullClassName = mClassName.replace('.', '/');

        findArchitecture();

        findNativeMethods();
    }

    private void findArchitecture() {
        NativeClass nc = mClazz.getAnnotation(NativeClass.class);
        mTargetArch = nc.arch();
    }

    private void findNativeMethods() {
        List<? extends Element> elements = mClazz.getEnclosedElements();
        for (Element e : elements) {
            if (e.getKind().equals(ElementKind.METHOD)) {
                if (e.getModifiers().contains(Modifier.NATIVE)) {
                    mMethods.add(e);
                } else if (e.getAnnotation(NativeMethod.class) != null) {
                    warn("Annotation @" + NativeMethod.class.getSimpleName() + " should only be applied to NATIVE method!");
                }
            }
        }
    }

    private void log(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.NOTE,
                msg);
    }

    private void warn(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.WARNING,
                msg);
    }

    public void genHeader() {
        File header = new File(mHeaderName);
        if (header.exists()) header.delete();
        if (header.exists() && !header.canWrite()) {
            warn("output file " + header.getName() + " can not be written");
            return;
        }
        PrintWriter w = null;
        try {
            w = new PrintWriter(new BufferedOutputStream(
                    new FileOutputStream(header)
            ));
            final String defineSwitch = "_Included_" + mJNIClassName;
            w.println("/* JNI Header file " +
                    "generated by annotation JNI helper */\n" +
                    "#include <jni.h>");
            w.println("/* header file for class " + mClassName + " */\n");
            w.println("#ifndef " + defineSwitch);
            w.println("#define " + defineSwitch);
            w.println("#ifdef __cplusplus\n" +
                    "extern \"C\" {\n" +
                    "#endif\n");


            generateConstantsDefination(w);

            w.print("\n#define FULL_CLASS_NAME \"");
            w.print(mFullClassName);
            w.println("\"\n");

            w.println("\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);\n" +
                    "JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);\n");
            writeFunctions(w, false);
            w.println("\n#ifdef __cplusplus\n" +
                    "}\n" +
                    "#endif");
            w.println("#endif");
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    private void generateConstantsDefination(PrintWriter w) {
        for (Element e : mClazz.getEnclosedElements()) {
            if (e.getKind().equals(ElementKind.FIELD)) {
                VariableElement ve = (VariableElement) e;
                //if this field is a compile-time constant value it's
                //value will be returned, otherwise null will be returned.
                Object constValue = ve.getConstantValue();
                if (constValue != null) {
                    String defineName = mJNIClassName + "_" + ve.getSimpleName();
                    w.print("#undef ");
                    w.println(defineName);
                    w.print("#define ");
                    w.print(defineName);
                    w.print(' ');
                    w.println(HandyHelper.getJNIHeaderConstantValue(constValue, mTargetArch));
                }
            }
        }
    }


    public void genSource() {
        File source = new File(mSourceName);
        if (source.exists()) source.delete();
        if (source.exists() && !source.canWrite()) {
            warn("output file " + source.getName() + " can not be written");
            return;
        }
        PrintWriter w = null;
        try {
            w = new PrintWriter(new BufferedOutputStream(
                    new FileOutputStream(source)
            ));

            w.println("#include \"" + mHeaderName + "\"\n");
            writeFunctions(w, true);

            //write JNI_OnLoad & JNI_OnUnload
            writeSourceTail(w);
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    private static void closeSilently(Closeable c) {
        if (c == null) return;
        try {
            c.close();
        } catch (IOException e) {

        }
    }

    private void writeFunctions(PrintWriter w, boolean isSource) {
        for (Element m : mMethods) {
            ExecutableElement e = (ExecutableElement) m;

            //write comment
            w.print("/*\n" +
                    " * Class:     ");
            w.println(mJNIClassName);
            w.print(" * Method:    ");
            w.println(m.getSimpleName().toString());
            w.print(" * Signature: ");
            w.println(HandyHelper.getMethodSignature(e));
            w.println(" */");

            w.print(HandyHelper.toJNIType(e.getReturnType(), mEnv.typeUtils));
            w.print(" ");
            w.print(m.getSimpleName().toString());
            w.print("(JNIEnv *env");

            if (m.getModifiers().contains(Modifier.STATIC)) {
                w.print(", jclass clazz");
            } else {
                w.print(", jobject thiz");
            }

            List<? extends VariableElement> params = e.getParameters();
            for (VariableElement ve : params) {
                w.print(", ");
                w.print(HandyHelper.toJNIType(ve.asType(), mEnv.typeUtils));
                w.print(' ');
                w.print(ve.getSimpleName().toString());
            }
            if (!isSource) {
                w.println(");\n");
            } else {
                w.write(") {\n");
                NativeMethod a = m.getAnnotation(NativeMethod.class);
                if (a != null) {
                    for (String s : a.value()) {
                        w.print("    ");
                        w.println(s);
                    }
                }
                w.println("}\n");
            }

        }
    }

    private void writeSourceTail(PrintWriter w) {
        w.println("static const JNINativeMethod gsNativeMethods[] = {");
        int methodLen = mMethods.size();
        for (int i = 0; i < methodLen; i++) {
            if (i == 0) {
                w.println('{');
            } else {
                w.println("}, {");
            }
            writeNativeMethodMapArray((ExecutableElement) mMethods.get(i), w);
            if (i == methodLen - 1) {
                w.println("}");
            }
        }
        w.println("};\n" +
                "static const int gsMethodCount = sizeof(gsNativeMethods) / sizeof(JNINativeMethod);\n");

        //JNI_OnLoad
        w.println("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n" +
                "    JNIEnv* env;\n" +
                "    jclass clazz;\n" +
                "    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {\n" +
                "        return -1;\n" +
                "    }\n" +
                "    clazz = env->FindClass(FULL_CLASS_NAME);\n" +
                "    //register JNI Function\n" +
                "    env->RegisterNatives(clazz, gsNativeMethods,\n" +
                "        gsMethodCount);\n" +
                "    " +
                "    return JNI_VERSION_1_6;\n" +
                "}\n");

        //JNI_OnUnload
        w.println("JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved) {\n    \n}");
    }

    private void writeNativeMethodMapArray(ExecutableElement method,
                                           PrintWriter w) {
        final String methodName = method.getSimpleName().toString();
        w.print("const_cast<char *>(");
        w.print('\"');
        w.print(methodName);
        w.println("\"),");

        w.print("const_cast<char *>(");
        w.print('\"');
        w.print(HandyHelper.getMethodSignature(method));
        w.println("\"),");

        w.print("reinterpret_cast<void *>(");
        w.print(methodName);
        w.println(')');
    }

}
