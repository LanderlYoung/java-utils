package com.young.util.jni.generator;

import com.young.util.jni.JNIHelper;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.Closeable;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.List;

/**
 * Author: taylorcyang
 * Date:   2014-12-17
 * Time:   16:03
 * Life with passion. Code with creativity!
 */
public class CppCodeGenerator implements Runnable {
    private final Environment mEnv;
    private final TypeElement mClazz;
    private List<Element> mMethods;

    //like com.example_package.SomeClass$InnerClass
    private String mClassName;
    //like com_example_1package_SomeClass_InnerClass
    private String mJNIClassName;
    //like com/example_package/SomeClass$InnerClass
    private String mNativeClassSignature;

    //header file name
    private String mHeaderName;
    //source file Name
    private String mSourceName;
    //target c/c++ file machine architecture
    private int mTargetArch;


    //DONE JNIHelper.toJNIType throwable
    //DONE Use NativeClass to mark generate, NativeMethod to add implements
    //DELETE different constant value for different arch
    //FIXME fix get package name
    //TODO support for inner class
    //TODO support for pure c code
    //TODO file output

    public CppCodeGenerator(Environment env,
                            TypeElement clazz) {
        mEnv = env;
        mClazz = clazz;
        mMethods = new LinkedList<Element>();
    }

    @Override
    public void run() {
        doGenerate();
    }

    public void doGenerate() {
        if (init() && !mMethods.isEmpty()) {
            genHeader();
            genSource();
        }
    }

    private boolean init() {
        if (!mClazz.getKind().equals(ElementKind.CLASS)) return false;

        mClassName = HandyHelper.getClassName(mClazz, mEnv.elementUtils);
        mJNIClassName = JNIHelper.toJNIClassName(mClassName);
        mHeaderName = mJNIClassName + ".h";
        mSourceName = mJNIClassName + ".cpp";
        mNativeClassSignature = JNIHelper.getNativeClassName(mClassName);

        findArchitecture();

        findNativeMethods();

        return true;
    }

    private void findArchitecture() {
        NativeClass nc = mClazz.getAnnotation(NativeClass.class);
        //in normal ways, nc is not possible to be null
        if (nc != null) mTargetArch = nc.arch();
    }

    private void findNativeMethods() {
        List<? extends Element> elements = mClazz.getEnclosedElements();
        for (Element e : elements) {
            if (e.getKind().equals(ElementKind.METHOD)) {
                if (e.getModifiers().contains(Modifier.NATIVE)) {
                    mMethods.add(e);
                } else if (e.getAnnotation(NativeSource.class) != null) {
                    warn("Annotation @" + NativeSource.class.getSimpleName() + " should only be applied to NATIVE method!");
                }
            }
        }
    }

    private void log(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.NOTE,
                msg);
    }

    private void warn(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.WARNING,
                msg);
    }

    public void genHeader() {
        PrintWriter w = null;
        try {
            //JavaFileObject fileObject = mEnv.filer.createSourceFile(mHeaderName);
            FileObject fileObject = mEnv.filer.createResource(StandardLocation.SOURCE_OUTPUT, "", mHeaderName);
            w = new PrintWriter(fileObject.openWriter());

            //mEnv.messager.printMessage(Diagnostic.Kind.ERROR,
            //        fileObject.getName());

            //w = new PrintWriter(new BufferedOutputStream(
            //        new FileOutputStream(header)
            //));
            final String defineSwitch = "_Included_" + mJNIClassName;
            w.println("/* JNI Header file " +
                    "generated by annotation JNI helper */\n" +
                    "#include <jni.h>");
            w.println("/* header file for class " + mClassName + " */\n");
            w.println("#ifndef " + defineSwitch);
            w.println("#define " + defineSwitch);
            w.println("#ifdef __cplusplus\n" +
                    "extern \"C\" {\n" +
                    "#endif\n");


            generateConstantsDefination(w);

            w.println("\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);\n" +
                    "JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);\n");
            writeFunctions(w, false);
            w.println("#ifdef __cplusplus\n" +
                    "}\n" +
                    "#endif");
            w.println("#endif");
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    private void generateConstantsDefination(PrintWriter w) {
        for (Element e : mClazz.getEnclosedElements()) {
            if (e.getKind().equals(ElementKind.FIELD)) {
                VariableElement ve = (VariableElement) e;
                //if this field is a compile-time constant value it's
                //value will be returned, otherwise null will be returned.
                Object constValue = ve.getConstantValue();
                if (constValue != null) {
                    String defineName = mJNIClassName + "_" + ve.getSimpleName();
                    w.print("#undef ");
                    w.println(defineName);
                    w.print("#define ");
                    w.print(defineName);
                    w.print(' ');
                    w.println(HandyHelper.getJNIHeaderConstantValue(constValue, mTargetArch));
                }
            }
        }
    }


    public void genSource() {
        PrintWriter w = null;
        try {
            FileObject fileObject = mEnv
                    .filer
                    .createResource(StandardLocation.SOURCE_OUTPUT
                            , "", mSourceName);
            w = new PrintWriter(fileObject.openWriter());

            w.println("#include \"" + mHeaderName + "\"\n");

            w.print("\n//java class name: ");
            w.println(mClassName);
            w.print("#define FULL_CLASS_NAME \"");
            w.print(mNativeClassSignature);
            w.println("\"\n");

            writeFunctions(w, true);

            //write JNI_OnLoad & JNI_OnUnload
            writeSourceTail(w);
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    private static void closeSilently(Closeable c) {
        if (c == null) return;
        try {
            c.close();
        } catch (IOException e) {

        }
    }

    private void writeFunctions(PrintWriter w, boolean isSource) {
        for (Element m : mMethods) {
            ExecutableElement e = (ExecutableElement) m;

            //write comment
            w.print("/*\n" +
                    " * Class:     ");
            w.println(mJNIClassName);
            w.print(" * Method:    ");
            w.print(mClassName);
            w.print('.');
            w.println(m.getSimpleName().toString());
            w.print(" * Signature: ");
            w.println(HandyHelper.getMethodSignatureForNative4Code(e));
            w.println(" */");

            w.print(HandyHelper.toJNIType(e.getReturnType(), mEnv.typeUtils));
            w.print(" ");
            w.print(m.getSimpleName().toString());
            w.print("(JNIEnv *env");

            if (m.getModifiers().contains(Modifier.STATIC)) {
                w.print(", jclass clazz");
            } else {
                w.print(", jobject thiz");
            }

            List<? extends VariableElement> params = e.getParameters();
            for (VariableElement ve : params) {
                w.print(", ");
                w.print(HandyHelper.toJNIType(ve.asType(), mEnv.typeUtils));
                w.print(' ');
                w.print(ve.getSimpleName().toString());
            }
            if (!isSource) {
                w.println(");\n");
            } else {
                w.write(") {\n");
                NativeSource a = m.getAnnotation(NativeSource.class);
                if (a != null) {
                    for (String s : a.value()) {
                        w.print("    ");
                        w.println(s);
                    }
                }
                w.println("}\n");
            }

        }
    }

    private void writeSourceTail(PrintWriter w) {
        w.println("static const JNINativeMethod gsNativeMethods[] = {");
        int methodLen = mMethods.size();
        for (int i = 0; i < methodLen; i++) {
            if (i == 0) {
                w.println('{');
            } else {
                w.println("}, {");
            }
            writeNativeMethodMapArray((ExecutableElement) mMethods.get(i), w);
            if (i == methodLen - 1) {
                w.println("}");
            }
        }
        w.println("};\n" +
                "static const int gsMethodCount = sizeof(gsNativeMethods) / sizeof(JNINativeMethod);\n");

        //JNI_OnLoad
        w.println("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n" +
                "    JNIEnv* env;\n" +
                "    jclass clazz;\n" +
                "    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {\n" +
                "        return -1;\n" +
                "    }\n" +
                "    clazz = env->FindClass(FULL_CLASS_NAME);\n" +
                "    //register JNI Function\n" +
                "    env->RegisterNatives(clazz, gsNativeMethods,\n" +
                "        gsMethodCount);\n" +
                "    " +
                "    return JNI_VERSION_1_6;\n" +
                "}\n");

        //JNI_OnUnload
        w.println("JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved) {\n    \n}");
    }

    private void writeNativeMethodMapArray(ExecutableElement method,
                                           PrintWriter w) {
        final String methodName = method.getSimpleName().toString();
        w.print("const_cast<char *>(");
        w.print('\"');
        w.print(methodName);
        w.println("\"),");

        w.print("const_cast<char *>(");
        w.print('\"');
        w.print(HandyHelper.getMethodSignature(method));
        w.println("\"),");

        w.print("reinterpret_cast<void *>(");
        w.print(methodName);
        w.println(')');
    }

}
