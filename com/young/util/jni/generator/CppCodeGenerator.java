package com.young.util.jni.generator;

import com.young.util.jni.JNIHelper;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;
import javax.tools.Diagnostic;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

/**
 * Author: taylorcyang
 * Date:   2014-12-17
 * Time:   16:03
 * Life with passion. Code with creativity!
 */
public class CppCodeGenerator implements Runnable {
    final Element mClazz;
    final List<? extends Element> mMethods;
    private Filer mFiler;
    private String mClassName;
    private String mJNIClassName;
    private String mFullClassName;
    private String mHeaderName;
    private String mSourceName;

    //TODO JNIHElper.toJNIType throwable
    //TODO Use NativeClass to mark generate, NativeMethod to add implements
    //TODO file output

    //FIXME remove
    public static Messager messager;

    public CppCodeGenerator(Element clazz,
                            List<? extends Element> methods) {
        mClazz = clazz;
        mMethods = methods;
        initNames();
    }

    private void initNames() {
        assert mClazz.getKind().equals(ElementKind.METHOD);
        Element pkg = mClazz.getEnclosingElement();
        String pkgName = pkg.getSimpleName().toString();
        String className = mClazz.getSimpleName().toString();
        mClassName = pkgName + '.' + className;
        mJNIClassName = JNIHelper.toJNIClassName(mClassName);
        mHeaderName = "_" + mJNIClassName + ".h";
        mSourceName = "_" + mJNIClassName + ".cpp";
        mFullClassName = mClassName.replace('.', '/');
    }

    @Override
    public void run() {
        genHeader();
        genSource();
    }

    private static void log(String msg) {
        messager.printMessage(Diagnostic.Kind.NOTE,
                msg);
    }

    public void genHeader() {
        File header = new File(mHeaderName);
        if (header.exists()) header.delete();
        PrintWriter w = null;
        try {
            w = new PrintWriter(new BufferedOutputStream(
                    new FileOutputStream(header)
            ));
            final String defineSwitch = "_Included_" + mJNIClassName;
            w.println("/* JNI Header file " +
                    "generated by annotation JNI helper */\n" +
                    "#include <jni.h>");
            w.println("/* header file for class " + mClassName + " */\n");
            w.println("#ifndef " + defineSwitch);
            w.println("#define " + defineSwitch);
            w.println("#ifdef __cplusplus\n" +
                    "extern \"C\" {\n" +
                    "#endif\n");

            w.print("#define FULL_CLASS_NAME \"");
            w.print(mFullClassName);
            w.println("\"\n");

            w.println("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);\n" +
                    "JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);\n");
            writeFunctions(w, false);
            w.println("\n#ifdef __cplusplus\n" +
                    "}\n" +
                    "#endif");
            w.println("#endif");
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    public void genSource() {
        File source = new File(mSourceName);
        if (source.exists()) source.delete();
        PrintWriter w = null;
        try {
            w = new PrintWriter(new BufferedOutputStream(
                    new FileOutputStream(source)
            ));

            w.println("#include \"" + mHeaderName + "\"\n");
            writeFunctions(w, true);

            //write JNI_OnLoad & JNI_OnUnload
            writeSourceTail(w);
        } catch (IOException e) {

        } finally {
            closeSilently(w);
        }
    }

    private static void closeSilently(Closeable c) {
        if (c == null) return;
        try {
            c.close();
        } catch (IOException e) {

        }
    }

    private void writeFunctions(PrintWriter w, boolean isSource) {
        for (Element m : mMethods) {
            ExecutableElement e = (ExecutableElement) m;

            //write comment
            w.print("/*\n" +
                    " * Class:     ");
            w.println(mJNIClassName);
            w.print(" * Method:    ");
            w.println(m.getSimpleName().toString());
            w.print(" * Signature: ");
            w.println(Helper.getMethodSignature(e));
            w.println(" */");

            w.print(Helper.toJNIType(e.getReturnType().toString()));
            w.print(" ");
            w.print(m.getSimpleName().toString());
            w.print("(JNIEnv *env");

            if (m.getModifiers().contains(Modifier.STATIC)) {
                w.print(", jclass clazz");
            } else {
                w.print(", jobject thiz");
            }

            List<? extends VariableElement> params = e.getParameters();
            for (VariableElement ve : params) {
                w.print(", ");
                w.print(Helper.toJNIType(ve.asType().toString()));
                w.print(' ');
                w.print(ve.getSimpleName().toString());
            }
            if (!isSource) {
                w.println(");\n");
            } else {
                w.write(") {\n");
                NativeMethod a = m.getAnnotation(NativeMethod.class);
                if (a != null) {
                    for (String s : a.value()) {
                        w.write("    ");
                        w.println(s);
                    }
                }
                w.println("}\n");
            }

        }
    }

    private void writeSourceTail(PrintWriter w) {
        w.println("static JNINativeMethod gsNativeMethods[] = {");
        int methodLen = mMethods.size();
        for (int i = 0; i < methodLen; i++) {
            if (i == 0) {
                w.println('{');
            } else {
                w.println("}, {");
            }
            writeNativeMethodMapArray((ExecutableElement) mMethods.get(i), w);
            if (i == methodLen - 1) {
                w.println("}");
            }
        }
        w.println("};\n" +
                "static const int gsMethodCount = sizeof(gsNativeMethods) / sizeof(JNINativeMethod);\n");

        //JNI_OnLoad
        w.println("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n" +
                "    JNIEnv* env;\n" +
                "    jclass clazz;\n" +
                "    LOGD(\"JNI_OnLoad called\");\n" +
                "    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {\n" +
                "        return -1;\n" +
                "    }\n" +
                "    clazz = env->FindClass(FULL_CLASS_NAME);\n" +
                "    //register JNI Function\n" +
                "    env->RegisterNatives(clazz, gsNativeMethods,\n" +
                "        gsMethodCount);\n" +
                "    " +
                "    return JNI_VERSION_1_6;\n" +
                "}\n");

        //JNI_OnUnload
        w.println("JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved) {\n}");
    }

    private void writeNativeMethodMapArray(ExecutableElement method,
                                           PrintWriter w) {
        final String methodName = method.getSimpleName().toString();
        w.print('\"');
        w.print(methodName);
        w.println("\",");

        w.print('\"');
        w.print(Helper.getMethodSignature(method));
        w.println("\",");

        w.print("reinterpret_cast<void *>(");
        w.print(methodName);
        w.println(')');
    }

}
